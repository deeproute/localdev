apiVersion: helm.toolkit.fluxcd.io/v2beta1
kind: HelmRelease
metadata:
  name: vault
spec:
  values:
    server:
      ha:
        enabled: true
        replicas: 3
      # Enables Vault's integrated Raft storage.  Unlike the typical HA modes where
      # Vault's persistence is external (such as Consul), enabling Raft mode will create
      # persistent volumes for Vault to store data according to the configuration under server.dataStorage.
      # The Vault cluster will coordinate leader elections and failovers internally.
      raft:

        # Enables Raft integrated storage
        enabled: true
        # Set the Node Raft ID to the name of the pod
        setNodeId: false

        # Note: Configuration files are stored in ConfigMaps so sensitive data
        # such as passwords should be either mounted through extraSecretEnvironmentVars
        # or through a Kube secret.  For more information see:
        # https://www.vaultproject.io/docs/platform/k8s/helm/run#protecting-sensitive-vault-configurations
        config: |
          ui = true

          listener "tcp" {
            tls_disable = 1
            address = "[::]:8200"
            cluster_address = "[::]:8201"
          }

          storage "raft" {
            path = "/vault/data"
          }

          service_registration "kubernetes" {}

    config: |
        ui = true

        listener "tcp" {
          tls_disable = 1
          address = "[::]:8200"
          cluster_address = "[::]:8201"
        }
        storage "consul" {
          path = "vault"
          address = "HOST_IP:8500"
        }

        service_registration "kubernetes" {}

        # Example configuration for using auto-unseal, using Google Cloud KMS. The
        # GKMS keys must already exist, and the cluster must have a service account
        # that is authorized to access GCP KMS.
        #seal "gcpckms" {
        #   project     = "vault-helm-dev-246514"
        #   region      = "global"
        #   key_ring    = "vault-helm-unseal-kr"
        #   crypto_key  = "vault-helm-unseal-key"
        #}
    
    # Definition of the serviceAccount used to run Vault.
    # These options are also used when using an external Vault server to validate
    # Kubernetes tokens.
    # serviceAccount:
      # Specifies whether a service account should be created
      # create: true
      # The name of the service account to use.
      # If not set and create is true, a name is generated using the fullname template
      # name: ""
      # Extra annotations for the serviceAccount definition. This can either be
      # YAML or a YAML-formatted multi-line templated string map of the
      # annotations to apply to the serviceAccount.

    ui:
      enabled: true

    affinity: null # Use only for dev
    
    # podDisruptionBudget:
    #   maxUnavailable: 1
    
    ingress:
      enabled: true
      ingressClassName: "nginx-internal"
      pathType: Prefix
      activeService: true
      hosts:
        - host: chart-example.local
          paths: []
      ## Extra paths to prepend to the host configuration. This is useful when working with annotation based services.
      extraPaths: []
      # - path: /*
      #   backend:
      #     service:
      #       name: ssl-redirect
      #       port:
      #         number: use-annotation
      tls: []
      #  - secretName: chart-example-tls
      #    hosts:
      #      - chart-example.local
    
    # authDelegator enables a cluster role binding to be attached to the service
    # account.  This cluster role binding can be used to setup Kubernetes auth
    # method.  https://www.vaultproject.io/docs/auth/kubernetes.html
    # authDelegator:
    #   enabled: true

    # extraInitContainers is a list of init containers. Specified as a YAML list.
    # This is useful if you need to run a script to provision TLS certificates or
    # write out configuration files in a dynamic way.
    extraInitContainers: null
      # # This example installs a plugin pulled from github into the /usr/local/libexec/vault/oauthapp folder,
      # # which is defined in the volumes value.
      # - name: oauthapp
      #   image: "alpine"
      #   command: [sh, -c]
      #   args:
      #     - cd /tmp &&
      #       wget https://github.com/puppetlabs/vault-plugin-secrets-oauthapp/releases/download/v1.2.0/vault-plugin-secrets-oauthapp-v1.2.0-linux-amd64.tar.xz -O oauthapp.xz &&
      #       tar -xf oauthapp.xz &&
      #       mv vault-plugin-secrets-oauthapp-v1.2.0-linux-amd64 /usr/local/libexec/vault/oauthapp &&
      #       chmod +x /usr/local/libexec/vault/oauthapp
      #   volumeMounts:
      #     - name: plugins
      #       mountPath: /usr/local/libexec/vault

    dataStorage:
      enabled: true
      # Size of the PVC created
      size: 500Mi

    standalone:
      enabled: false

    
  # resources:
  #   requests:
  #     memory: 256Mi
  #     cpu: 250m
  #   limits:
  #     memory: 256Mi
  #     cpu: 250m

